# Wufisher recordBook_1

thank ac_oier

update 2022/2/7  catched

### 384.打乱数组


    洗牌算法 数组乱序等可能


### 519.随机翻转矩阵


    将二维转为一维，双指针，一个指针从随机到位置向坐，一个向右，每次随机得到不重复的坐标


### 53.最大子序和


    核心思想：利用一个sum保存前面之和大于0，若小于0则代表负影响，更新为新值


### 562.矩阵中最长连续1线段


    分成四个方向的动态规划dp


### 1746.经过一次操作后的最大子数组和


    操作为将一个数平方
    
    最大子数组肯定包含操作，利用两个dp1，2，分别记录当前i个加入进去后（可能操作也可能之前有操作），有操作和无操作的最大值。


### 152.乘积最大子数组


    动态规划需要保存两种情况
    
    以i结尾的最大值，和以i结尾的最小值

    乘法和加法存在一定区别，可能负数×小值可能会更大


### 458.可怜的小猪


    毒药问题，检测次数k可以转为k+1进制的一个表示问题
    香农熵定理
    只数为 LOGM/LOG(K+1)


### 423.从英文中重建数字


    考虑每一个数字在当前选取域独有的字母，例如8的h
    
    优化统计不重复


### 859.亲密字符串


    词频统计，且有一个字符串必须交换一次——》1.恰巧能交换两个2.若完全相同，则必须有一个的词频>1


### 376.摆动序列


    将摆动序列分为最后一个为降down，最后一个为升up两种情况来处理

    只用比较i和i-1的值，如果更大，则up变为up和down+1的max（不必考虑i-1是不是up或者down最后一位）由于down和up可以对于新节点可以选择为相对最小和最大值，所以一定能够加入进去


### 买卖股票.


    309.含冷冻期
    714.含手续费
    121.基础版
    (后面有总结处理)


### 1035.不相交的线


    字符串匹配动态规划


### 599.两个列表最小索引综合？

### 343.整数拆分？
    数学题：将整数优先拆成相等的，乘积最大，且计算出值为e,（2，3比较后选择3）
    如果余数为2，则不再拆分，如果余数为1，则还要把之前的3和这个1组合为2+2
### 64.最小路径和


    动态规划


### 397.整数替换


    位运算，化为二进制处理问题


### 488.祖玛游戏！？？？
    DFS暴搜+剪支，考虑用int记录字符串而不同时构造两个字符串
    这里有一个非常重要的剪枝（选择插入的操作策略）
```java    
    boolean ok = false;
    //自己与插入位置的颜色不相同，但是可以插在两个相同颜色的中间
    // 例如 RRWWRRBBRR 和 WB 这个测试用例：
    // 正确答案是在最后两个R中插入一个W，其他解决方案都会剩下两个字母没法消除。
    if(j>0&&j<n&&a.charAt(j)==a.charAt(j-1)&&a.charAt(j-1)!=b.charAt(i))
        ok = true;
    //插入位置和自己颜色一样
    if(j<n&&a.charAt(j)==b.charAt(i))
        ok= true;
    if(!ok) continue;
```
    还有a*优化，年后在写

### 438.找到字符串中所有异位字词


    窗口化双指针词频统计，动态更新头尾

    优化：利用变量记录当前已经匹配的字母，只用一个词频数组


### 653.二叉树的坡度


    递归遍历左右子树


### 487.最大连续1的个数


    （有一个将0反转为1的机会）
    
    双动态变量，记录包含i且当前连续子串是否使用过翻转的机会，在和ans比较取最大，
    
    优化：可以不断输入，且不需要占用空间,dp1记录用过的，dp2记录没用过


### 318.最大单词长度乘积
    由于全是小写字母，我们可以用int的二进制数表示该单词出现的字母种类，在利用**位运算**判断是否存在相同字符
    例如‘adb’ ——> 00000..01011（用1的左移和|运算实现）
    优化：利用哈希表，对于相同字母单词只用保存较大的
### 391.完美矩形？
    扫描线算法
    from三叶
    将每个矩形 rectangles[i]rectangles[i]rectangles[i] 看做两条竖直方向的边，使用 (x,y1,y2)(x, y1, y2)(x,y1,y2) 的形式进行存储（其中 y1y1y1 代表该竖边的下端点，y2y2y2 代表竖边的上端点），同时为了区分是矩形的左边还是右边，再引入一个标识位，即以四元组 (x,y1,y2,flag)(x, y1, y2, flag)(x,y1,y2,flag) 的形式进行存储。
    一个完美矩形的充要条件为：对于完美矩形的每一条非边缘的竖边，都「成对」出现（存在两条完全相同的左边和右边重叠在一起）；对于完美矩形的两条边缘竖边，均独立为一条连续的（不重叠）的竖边。
    具体扫描实现办法看代码



### 319.灯泡开关


    数学题
    
    小于等于n的完全平方数的个数为sqrt(n)，
    
    因子个数奇数有且仅有完全平方数


### 1143.最长公共子序列


    经典动态规划


### 667.键值映射


    tri树变形，只是说将结尾boolean类型改为了val值


### 1230.拋掷硬币


    动态规划，dp[i][j]描述i次抛掷，j次朝上

    dp[i][j]=dp[i-1][j-1]*A[i-1]（前i-1次只有j-1）+dp[i-1][j]*(1-A[i-1])（前i-1有j次）;


### 629.K个逆序對数组**


    二位动态规划，更大的数不会对前面小数的逆序对个数产生影响

    优化：利用前缀相同，优化储存求和


### 786.第K个最小的素数分类


    1.利用大根堆直接暴力


### 400.第N位数字


    模拟遍历，找出n个数字在数字长度为len的范围中，再找在第几个数字内部，在求模
    
    
    注意模拟的条件边界情况，通过整形对与除法的切断，找出n在len中哪一个数字里第几个


### 1446.连续字符


    因为是连续的，无论是双指针，我用的是单指针，模拟一遍即可


### 787.K站中转内最便宜的航班


    Bellman-Ford算法改进
    **两个改进都非常重点

    1.原算法中，因为最长路径节点为V，所以一共循环V-1次，本次 起+K+末共k+2，所以循环K+1ci1

    2.每一次循环中，对于改进路径 src——>v，必须**提前克隆dict[]数组**：这样保证伸缩的某个U节点，
    不会在本次循环中被伸缩（src->u）路径本次一定没有被修改，相当与**保证了每次给所有路径最多添加一个中专站路径节点**


### 506.相对名次


    简单模拟可以用hashmap存位次和分数，复制score排序得到分数排序    
    
    也可使用最大根堆存储，在弹出


### 133.克隆图


    深拷贝（对于引用对象的调用和浅拷贝明显不同）
    通过递归调用复制函数
    
    1.new新对象，将复制对象的属性，方法等等剥开，直到底层
    
    2.对其他对象（邻接等等），再次调用递归，返回等等
    
    **注意要标记哪些已经被复制过了


### 2089.找出数组排序后的目标下标


    有意思的在于排序的nlogn时间复杂度反而是高的，所以我们不要排序，直接统计
    
    
    target第一个下标为比target数量少的个数，target的重复为他的数量，复杂度将为n


### 1005.K次取反后最大化的数组和


    简单的模拟题
    注意K与数组中负数个数的关系，
    注意数组中0的个数


### 322.零钱兑换


    动态规划，从0到目标金额，步长为一，所以相对前序条件只用+1，注意不要超过大小


### 638.大礼包


    将每份商品礼包化处理，在dfs，配合剪枝调优


### 2090.半径为k的子树组平均值


    简单模拟，保存状态


### 372.超级次方


    快速幂：见代码写法，分治求解,代码为利用非递归位运算的写法——将二分处理奇数化为1，2，4，8，16....的线性组合

    (a*b)%mod = (a%mod * b%mod)%mod

    将主幂次将为两个在0-10的数，然后在递归求解
    a&1==1 a为奇数

    aK=a(⌊10K⌋∗10)+(Kmod10)=a(⌊10K⌋∗10)∗a(Kmod10)=(a⌊10K⌋)10∗a(Kmod10)



### 1034.边界着色
    BFS遍历，通过检查该模块四周是否都是同色来判断是否是边界，然后染色，最后记得把边界外面的染色（ans中）

### 689.三个无重叠子数组的最大和
    滑动窗口，将三个长度为k的窗口一起滑动
    **i=2*k为初始态，作为第三个数组的尾标记,当i加到3*k-1时（每个数组都尾加k个元素后）开始判断遍历
    当sum1>max1时，更新max1和idx1
    !!!其实后面的递归看来[]idx2可以作为两个无重叠字数组的最大和
    当max1+sum2>max12时，更新max12和[]idx2（idx2[0]=idx1,idx2[1]=i-2*k+1）
    当max12+sum3>max123时，更新max123和[]idx3（idx3[0]=idx2[0],idx3[1]=idx2[1],idx3[2]=i-k+1），
    并更新[]ans(ans=idx3)<---可看作本类问题的一个终止点
    
    *本题方法对于n个无重叠子数组都可以延伸
    *还可以用动态规划求解

### 794.有效的井字游戏
    模拟遍历输入数字，把所有情况判断一遍，时间复杂度O（n）

### 748.最短补全词
    词频统计，处理时后记得将大学字母处理为小写字母

### 911.在线选举
    通过记录每个时间段是哪一位总统当选，然后查找的时候利用时间递增的规则，二分查找到当前总统票数领先
    中间有个二分法是mid=(l+r+1)>>1，这+1是为了防止后面的操作中死循环
    
### 709.转换成小写字母
    学习下新函数 toLowerCase()

### 807.保持城市天际线
    贪心算法，计算出每一个坐标下楼高与作出该行该列最大值中较小的差之和

    
### 630.课程表 III
    经典贪心算法
    course中，course[i][0]为课程持续时间，course[i][1]为课程结束时间
    将course按结束时间升序排序，再建立大根优先队列q储存每一个选中课程的时间
    对于每一个course，优先入队，sum+=course;
    如果sum+course[0]<=course[1],则相容，跳到下一个course
    如果不相容同样加入，但是sum-=q.poll()弹出里面耗费时间最长的（可能是刚刚加入的）

    证明：对于数量x的课程，要么是从x-1中相容加入，要么是从x+1中弹出最长的，所以耗费时间一定是最短的
        贪心选择性：不相容情况下，一定会为后面留出最多的时间☝
                相容情况下，不加入相当于舍弃掉这个course，最后课程数量一定不会大于
        优化子结构：每个操作能够使得选课程容量+0 or +1，如果可以+2则证明子结构不是最优，矛盾

### 851.喧闹与富有
    首先利用拓扑排序建图，a比b有钱则建立a指向b的边,并且建立数组保存每个节点的入度，并将入度为0的节点入队
    弹出队列（t）然后查看t每一个相邻节点的quiet值，由于是按照拓扑排序，ans首先默认为自己，由于我们从入度为0
    的（更有钱的）往下遍历，如果quiet（t）<quiet(u)，则可以更新!!!ans(u),不是t，并且每次都是改变相邻的，所以一定是由比自己更有钱的遍历而来，保证了更新的答案正确性
    注意答案是人的标号而不是安静值


### 1610.可见点的最大数目
    细节较多的数学题，求极角
    将角度排序，并且如果该点在观测点上，则另作保存处理
    有一个非常重要的操作，在将角度排序完成之后，为了防止从第四象限到第一象限（相对于观测点）的角可能会被忽略掉，所以我们要把保存角的元素每一个+2PI，扩充在表里，最后利用滑动窗口检测

### 1518.换酒问题
    可以简单的模拟做法
    也还有数学解法
    每一次交换m空酒瓶，会得到一个杯子和一个喝酒次数，所以每次损失m-1个杯子，
    总共能损失的个数/m-1为交换次数，加上原瓶子数即可
    注意，如果n一开始为m-1的倍数，则最后一次不会满足（无法交换）


### 36.有效的数独
    简单的模拟一次，从行列和3*3方格保存记录

### 42.接雨水
    二维的一个接雨水，对于每个坐标i而言其实能够接到的雨水为
    min(leftmax[i],rightmax[i])-height(i),左右同时遍历得到一个从
    i以左或者以右最大的高度（包括i）

    提高：还可以利用双指针，节省空间复杂度,左右指针只保存左指针以左，右指针以右的最大，在看那一边更小，则更新那一边 leftmax-height(left),left++
    证明重点：由于每次都挑选的更小那一边，可以反证
    max([0:left])<max([right:n-1])
    也就是说对i而言，左边一定存在一个比右边更大的值，则只用考虑与右边最大值相减即可。最后l与r重合（迭代结束的时候，所处的点为最高点，这里不会保留雨水，所以不用计算）

### 419.甲板上的战舰
    模拟遍历，从上到下从左到右，发现不相邻，则才能保证是一艘新的战舰

### 997.找到小镇的法官
    小镇法官不相信任何人，其他人都信任法官  
    对于一个图而言（节点）相当于出度为0，入度为n-1

### 156.上下翻转二叉树
    注意前提条件，本题是以左节点作为头节点翻转，所以树是向左生长的，不用递归右子树
    并且，其实翻转完之后，其实只是图的指向改变了，可能本身布局并没有发生变化，所以我们可以利用递归返回左子树新的根节点，再通过栈的回退从左往上修缮结构

### 475.供暖器
    答案具有二分性， 小于半径无法满足，大于等于答案半径可以满足
    相当于我们对于答案的所有范围二分法求解
    所以我们可以人为的设定R的范围[0:1e9],用二分的思路求的可以满足的上届
    利用check函数check（h,h,mid）如果可以覆盖返回true，如果不能覆盖返回false
    来看当前的mid是处于上届以上还是以下，再改动设定的R范围
    操作重点之一：遍历的时候，先到房子应该处于哪一个热水器的范围（之前需要排好序）
                当房子的位置大于供暖器i半径时，至少是属于i+1供暖器

### 1154.一年中的第几天
    简单模拟打表题，还可以用api操作
    字符串的拆解操作

### 2109.向字符串添加空格
    在规定位置添加空格，字符串操作题，本题由于是加在制定位置前面，所以可以从后往前遍历做，最后记得翻转一下
        

### 686.重复叠加字符串的匹配
    首先得到一个复制的上下届：
    首先复制后的下届n1*a>=b
    并且上届最多为n1+1（b从第一个a的最后一个字符开始匹配）
    反证可以得出如果大于n1+1,则前面也能匹配（重复复制的字符串）
    indexOf匹配利用了kmp
    

### 1044.最长重复字符串
    我们可以对每个长度的字符串遍历check找到有无重复的，但是这样复杂度较高，所以我们利用hashset，和字符串哈希表配合，每个长度的遍历负责度修正为O（n）
    重点1：长度具有二分性，大于上界的一定不存在，小于等于下届的一定存在
        这里使用的是r+l+1>>1;成功l=mid,不成功r=mid-1（由于二分性成功的mid包含性确定，如果成功，下一个边界一定包含mid，如果不成功下一个边界的r一定不包含mid）
        ！有的是反过来的mid=r+l>>1,这里要注意二分的用法
    重点2：如何构建字符串哈希表
        int P = 1313131, n = s.length();
        h = new long[n + 10]; p = new long[n + 10];
        p[0] = 1;
        for (int i = 0; i < n; i++) {
            p[i + 1] = p[i] * P;
            h[i + 1] = h[i] * P + s.charAt(i);
        }
        p[i]中表示P的i次方
        h[i]表示从第1位到第i位的hash值（有效下标1——n）
        如何表示当前字符子串的哈希值
        cur = h[j] - h[i - 1] * p[j - i + 1];
        ！！这里的P值是实验出来的，一般来说不行就可以改大一点，hash函数是有因为溢出带来的冲突引起的问题，所以这里我们已经使用了long数组来保存

### 187.重复的DNA序列
    上面提到过的hash字符串题的基础版本，练手用

### 2110.股票平滑下降阶段
    其实比较偏向数学解法的一道题
    首先由于每一天也算一个平滑下降，anx+=n first
    然后就是讨论两个以上的区间，这里有个处理的小技巧，比如说，从i到j他是平滑下降的，那么i到j就有1+2+...（i-j）个子区间为平滑下降的（区间的长度从i-j+1到2），这里我们可以通过窗口的扩大，同时处理这个累加，把他加到ans上。

### 1705.吃苹果的最大数目
    贪心和优先队列的结合题
    由于每次我们只能吃一个苹果，所以对于树上每天产生的苹果，我们会利用小根堆存起来，<过期时间，个数>，每次优先吃过期时间最早的苹果
    处理的时候，如果time在n之前，则每天还可以产生苹果，要考虑入堆的事情，
    出堆后要考虑苹果是否过期，或者没过期的苹果是否吃完，分别作处理
    最后直到堆中元素全部退完

### 1944.队列中可以看到的人
    这道题按照要求来说，对于i个人，他能够看到的人的个数（j1,j2,j3.....jn）一定满足严格的单调递增，并且如果jn右边还有元素存在那么jn，jn+1>=i，那么我们不妨维护一个严格单调递增（从顶部到底部）从右到左的栈：
    对于新元素i而言，栈中元素直到为空，或者出现第一个不比他小的元素！！！之后！！！，遍历到所有栈的元素一定能被i看到，且不能被i-1之前的元素看到。在对i看到元素看完了之后，我们再把i入栈，且此时i在栈中元素一定至少为最小（或者为最小之一），满足单调栈的结构性质且能让i-1做同样的操作遍历。
    ！Java的deque默认push是到头

### 1609.奇偶树
    由于这个需要遍历每一层的单调严格递增或者递减，所以我们优先采取BFS
    BFS的时候每一层我们都切换一下标志变量flag代表奇偶，对当前层数的奇偶递增要求进行判断，我们找到错误就可以返回

### 1078.Bigram 分词
    简单的字符串模拟罢了（差点忘记了Arraylist如何转为[]）

### 825.适龄的朋友
    add 坏题，描述不够清晰

    首先我们首先将年龄排序，对于某一个年龄的人来说，交友请求的范围为比我小的不考虑，和我一样的或者比我大的（一定范围内考虑）（这里是以受到请求的人为中心考虑）
    那么其实对于每个人来说求友的范围可以用双指针来解决
    （本体来说能做朋友的指针下标为i,i+1,...j-1 not include k）
    还有桶子排序和前缀和的优化解法，后续步上
    
    续杯：对于上面的范围来说，其实很大优化步骤在于对于重复年龄人数的操作上
    
    比如对于某一个年龄的人来说，i岁的人有n个，对某一个人来说可以收到同龄人n-1，然后对于年龄大于他的人总共符合规律的人数m，每一条都可以收到，其实就是利用对年龄段人数的统计来优化指针移动的操作nums[i]中包含了从1岁到i岁中的人数，最后记得对于一个年龄来说是n*（n-1+m）<-注意这里还得判断n+m-1得大于0
    
    这个判断其实上一个做法也有，就是由于在判断中，其实对于y而言，给他发送请求的x的年龄最小的下届为和y同龄，但是也有可能虽然同龄但是不行
    
    本题目中y<=0.5x+7的时候不会收到x的请求，也就是说y 15岁以前同龄人也不行，而同龄的人都不会发消息的话，x年龄更大的人也一定不会发消息（这里就很迷，会导致需要添加一个判断）
    在题目一的做法中i>j，在题目二中nums[x-1]+nums[y-1]-1=-1(x==y),这里就需添加判断条件来解决。

    
### 472.连接词 
    解法一：将字符串哈希化，这里做一个set表，再遍历每一个字符串中是否能含有两个set以上的词
    解法二：trie字典树！！！一定要先将单词按照升列排序，去掉空单词，如果为非连接词则加入树，在遍历的时候每次遍历到重点就回到树的开头

### 1995.统计特殊四元组
    虽然说这个可以朴素模拟（数据范围有限制），但是还是学习一下多维背包的解法
    定义f[i][j][k]为考虑前i个物品（下标从1开始），凑成数值恰好为j,使用个数为k的方案数目
    随后对f[i][nums[i]][3]求和即可
    优化：可以进行维度优化
    因为每一次转移其实都依赖于f[i-1][x][x],所以我们可以把第一个维度优化掉，在转移的时候统计答案
    ！！！这里有个很关键的地方在于，之前我们的jk都是正序转移，而优化后我们需要逆序转移（jk从最大开始递减）
    ？？？为什么jk递减
    因为f[i][j][k]取决于f[i-1][j][k]和x,x<j,k的i-1维度，并且此时转移状态必须是i-1的状态转移过来，如果是jk递增转移，则jk较大的时候转移到了f[i][x][x]的状态，如果是递减则能够保证操作的一定来自于i-1个状态，且小于jk的状态不会发生改变。
    ？？？为什么这里不用要求从第四个数开始增加ans
    按照我们的ans+=f[nums[i]][3],当前面个数小于3时，其实按照逻辑和f[0][0]=1初始优化条件来说
    第一个数处理完后，只有f[nums[0]][1]==1,第二个数字处理完之后f[x][2](k=2)的维度才会出现1，所以这里不用考虑ans从第三个开始才加f[nums[i]][3],必然要自身到第四个数字之后，才可能+1
    

### 846.一手顺子
    将这些牌分成规定groupsize张一组，且每一组都是连续
    数据结构模拟题，哈希map配合优先队列
    由于每一组都要找顺子，其实也就是每个元素都要有相邻的元素，我们对于每个组而言，每次保证递增的话只需要我们对每一组开始模拟，都取最小值，由于数字可以重复，所以我们hash表中还要存放数字出现的次数，当需要他的时候他不存在或者数目在本次模拟中已经被减到0，就该数字肯定无法构成某一个组里面的元素，也就无法划分了


### 507.完美数
    模拟题，这里对于因数的优化在i<=num/i上，避免了使用sqrt函数
    并且因数成对出现，所以我们记得把一大一小都模拟加上
    个人认为这里需要针对完全平方数，处理一下整数根的问题

### 2119.翻转两次的数字
    要么为0，要么数字末尾不带0

### 2120.执行所有后缀指令
    暴力模拟即可
    记得case要break

### 2121.相同元素的间隔之和
    计算所有相同元素的下标差之和
    数学题
    这里是通过得到相同元素第一个和其他的距离，推算出其他元素到另外所有元素的距离（具体看代码，java第一大佬太强了）
    Java HashMap computeIfAbsent() 方法
    hashmap.computeIfAbsent(K key, Function remappingFunction)
    如果 key 对应的 value 不存在，则使用获取 remappingFunction 重新计算后的值，并保存为该 key 的 value，否则返回 value。

``` java
Map<Integer, List<Integer>> map = new HashMap<>();
map.computeIfAbsent(arr[i], t -> new ArrayList<>()).add(i);
```
    这一段代码的意思是，如果map中没有arr[i]的key值的时候，重新加入一个(arr[i],List[])的entry(执行后面的lambda函数)，并且返回list，这里后续的add(i)为操作他返回的list.add(i)

### 390.消除游戏
    数字1，n严格连续升序，从左到右面删，从右到左删（间隔），返回最后剩下的元素
    类似于求解约瑟夫环
    设f[i]为[1,i]删去后剩下左边的编号，带`的为从右边删除左边剩下的,得到的结果具有对称性    
$f[i]+f′[i]=i+1$

$f[i]=2*f′[i/2]$

$f[i]=2∗(⌊i/2​⌋+1−f[⌊i/2​⌋]$


### 1185.一周中的第几天
    模拟题

### 913.猫鼠游戏
    非常厉害的博弈类型题目
    动态规划（本题数据范围小）结合深度搜索
    这个动态规划其实是从f[0][1][2]开始往外推拓展，然后又收缩回f[0][1][2]起点，最终答案在f[0][1][2]上，因为我们不知道最终要走多少步
    f[k][i][j]=
    0:平局
    1:老鼠胜利
    2：猫胜利
    -1：状态初始化
    k：已经走了的步数
    i:老鼠当前位置
    j:猫当前的位置
    当k为偶数（老鼠移动）优先移动到1，0，2
    当k为奇数（猫移动）优先移动到2，0，1，注意猫不能进洞！！
    
    如何判定平局呢
        由于这里说过状态最优，也就是说得到的结果一定要么是🐭赢，要么是😺赢，要么就是平局，所以平局一定是移动到循环的死局出现。
        当总的移动步数达到2n（移动状态为2*n*n）的时候，一定会出现相同的移动
        这里的剪支和动态规划在于如果之前对于下一某一个状态的转移出现了平局，其实就是没有定下来的时候，会选择下一个状态，如果出现过之前已经操作过的状态，他的f已经从-1，变为0，1，2（多半是0和对方赢），这样就不要跳出循环以及退回返回答案，因为我们的目标是走到这里的优先级永远返回的是考虑！！对方所有可能性！！后，赢，平局，输
    为什么这里dfs到自己赢就可以一路退回最终答案呢
        因为这里如果dfs win为1，那么就是要么马上就赢了，或者要么就是对方无论怎么走，对方为平局，或者走到这一步，自己必输。

    总结一下就是(对于老鼠而言)
        f[k][i][j]来说，
        1.如果存在f[k+1][`i][j]=1,则f[k][i][j]为1
        2.如果f[k+1][`i][j]=0,则可能不是最好的情况，还可以继续判断，但是至少这下一步能够保证最差为打平局，并且储存状态
        3.如果f[k+1][*i][j]=2，所有都是2，那么这样就是必输的状态,f[k][i][j]=2,用于状态回退


### 1575.替换所有的问号
    简单的字符串模拟题
    模拟的时候只用与左右两个不一样，所以我们选择三个字母的范围就能解决所有问号的替换

### 5.最长回文子串
    其实由于左右边界能否扩展也要取决与间两个元素，可以很明显的用动态规划来完成
    这里我没有用动态规划，我把他的状态转移方程利用与一个中心的扩展，来得到最长的长度及其范围

### 10.正则表达式匹配
    动态规划
    f[i][j]= s中前i个字符（个数为i）与p中前j个字符是否能够匹配
    当匹配串中为字符时，其实就是正常的字符串匹配，但是这里带有两种特殊字符，我们的转移方程需要特殊处理
    当为'.'时，一定能够匹配
    当第j个字符为‘*’时，这里状态转移方程需要特殊处理
    将'a*'要看作一个整体，
    注：这里的索引为第几个而不是下标
    if(s[i],p[j-1])不匹配的时候，f[i][j]=f[i][j-2]，相当于丢弃这两个字符
    if(s[i],p[j-1])匹配的时候，f[i][j]=f[i][j-2] || f[i-1][j] 
    重点： 由于个数为0的也能匹配，所以这里的j不-1，因为他对于s中如果有多个可以匹配的情况，一定能够回溯到0个的情况（p没有包含'a*',s中多个连续的a之前）
    非常巧妙的处理了这个情况，相当于a*这个位置可以直接吃掉多个连续的‘a'（或者0个——>丢掉‘a*’），而不是需要和一般字符串匹配一样一对一换掉他
    并且说过要看成一个整体，所以这里我们只用考虑被匹配串 i-1 之前的是否匹配与包含‘a*’(前j个)的

    tips：这里对于i=0的情况也是要遍历的，比如说i="",j="a*b*c*"也是可以匹配的，或者我们之前说的他要回溯（吃掉s里面所有连续的a）,所以他的状态回溯会转移到不存在a的状态上面
    例如s='aa',p=‘a*’ ——>'','a*'——>'','' ==true

    总结这题主要是处理带*的，将带*号的0个情况巧妙的和多个情况进行一般化处理（1消多）

### 11.盛最多水的容器
    双指针，从数组两边向中间移动
    w=min(h[i],h[j])*(j-i)
    向中间移动的时候我们一定是选择移动较短的板（可以反证如果移动较长的板子装的水一定变少）

    可以证明如果两个指针板子长度一样移动哪一个不影响

    这里可以简单说明一下，
    比如如果两个相同的中间的可以收束成为一长一短或者都更短（对于相同长度边界来说），那么最终一定不可能大于之前的值
    如果中间存在两个更长的，那么最终一定会边界到达这两个更长的，并且可能出现更长的答案

### 71.简化路径
    字符串模拟题，因为有回退操作，所以这里我们直接用栈的结构
    栈里面只保存实际目标文件路径（不含特殊作用字符）
    跳过'.'，遇到'..'的时候弹出
    最后再从头弹出，生成答案字符串
    有的时候为了代码的简洁性，可以把i++>=0这种恒成立判断和&&并用，达到加加的效果
### wait do LFU算法


### 1614.括号的最大嵌套深度
    这里由于一定是有效字符串，所以我们从左到右模拟一遍即可，有一个左括号深度加1，右括号深度-1


### 407. 接雨水 II
    从四周往中间，配合dij算法（利用小根堆）求解的經典難題，先貼一下三葉佬的答案，過幾天自己再寫一遍


### 417.太平洋大西洋水流问题
    有點類似407，也需要從四邊往中間dfs
    需要找兩遍，一次从左上找从低到高能流到的地方，一次从右下找从边界低到高能流到的地方
    这里我们要拿两个数组分别保存一下，最后遍历两个都可以到达的即为答案

    这里再整两种Arraylist初始化的方法
    1：Arrays.asList()
    ArrayList<Type> obj = new ArrayList<Type>(Arrays.asList(Object o1, Object o2, Object o3, ....so on));
    这里其实Arrays.asList其实就返回了一个list，这里相当于迭代器，Arrays.asList(）可以单独使用
    2：匿名内部初始化
    ArrayList<T> obj = new ArrayList<T>() {{
    add(Object o1);
    add(Object o2);
    ...
    ...
    }};

### 89.格雷编码
    利用二进制转格雷码的方式转最简单


### 1036.逃离大迷宫
    这个题与常规迷宫的差距在于，他的总范围是超大的，但是障碍物所占的位置较小（面积）所以我们首先需要得到一个最大面积
    这里的想法是，我们对于出发点s和目标点t,我们都进行一遍BFS，要么就搜到了，要么如果两个都能搜到的面积大于MAX，证明一定没有被封闭，可以联通
    那么如何得到这个max呢，我们可以这样想，如何利用给定障碍物的数量，得到一个最大面积
    首先比较容易想到的是，斜边围成的比直边长（对于离散的坐标图而言）那么对于数量n个方块，他能围成的最大面积就是和给定最大边界作为直边，自己作为斜边，所围成的三角形就是最大的面积
    |*
    | *
    |  *
    |   *
    ———————   
    类似这种感觉
    这里可以肯定的是，如果二者没有都能达到这个最大面积，并且还没有搜到对方，则一定无法搜到
    但是如果两者都可以搜到超过这个最大面积，证明给定block无法将两个点隔离开来，也就一定能狗搜到
    这个max主要是为了解决TLE问题，给定一个较好的上界。
    本题利用hashset来记录已经被访问过的点

    对于坐标值我们利用一维来存储（x,y）->(x*131L+y)hash映射节约空间

### 334.递增的三元子序列
    判断是否存在长度为3的上升子序列，问题可以转化为LIS问题
    基于贪心和二分的做法
    遍历每个数的时候维护一个具有单调性的数组f[len]=x代表长度为len的最长上升子序列的最小结尾元素为x，并且显然f[]具有递增性，所以我们可以通过二分找到小于nums[i]的最大下标，作为nums[i]的前一个数
    在做法一中，对于遍历元素而言x其实就是找到f[len]=y,f[1,len]全都小于x,f[len]+1的值（可能为预设的0x3f3f3f3f或者之前被插入的值）大于x，相当于优化了递增的步幅减小，从而可以达到贪心得到最长递增子序列的结果

    优化解：
    由于只需要len为3就行了，所以我们只需要维护一个f[3+1]的数组，如果f[3]能够被赋值，那么就可以直接返回false.
    add这个取值很重要


### 1713.得到子序列的最少操作次数
    同时研究一下LCS 与 LIS 问题的相互关系，以及LIS问题儿带最优解证明
    LIS解决数组元素各不相同的问题有极大优化
    题目要求是在arr中插入任一整数，然后操作次数最少，得到一个tar的子序列（相对位置）（tar比arr要短）
    其实就是求得最长公共子序列max和tar长度n，最少操作次数为n-max
    正常的LCS做法就是学过的动态规划求公共子序列，但是如果题目的范围过大会导致超时，所以我们必须得换做法，转换成最长上升子序列问题LIS问题求解
    如果但看LIS问题其实上面的 334 （非该题的优化解解法）更加典型， 因为那个是严格要求的数组的值的 递增。

    所以这一题我们的重心在于如何抽象这一个递增的问题。

    由于元素互不相同，所以每一个下标与元素具有映射关系

    这个时候我们的上升序列就便成了下标上升的序列（由于公共相对顺序相同）

    朴素的LIS需要f[i] = 以 nums[i] 结尾的最长子序列的长度

    贪心的LIS维护一个额外的数组 g[len]= x 长度为len以x结尾的序列
    显然这个g数组具有单调递增的特性，所以我们可以用二分法进行操作
    （详见334）

    利用g更新f，球的最长上升子序列后，利用公共子序列和上升子序列的一一对应关系，得出最长公共子序列的长度

    先用一个map建立t数组元素和下标的一一对应关系
    然后再建立一个list保存公共元素的下标（注意此时下标的顺序不一定是升序，这里由于只要有公共元素便会加入其中）

    t: i , i+1 , i+2 , i+3 , i+4 .....
    
    arr: i , a , i + 3 , i + 2 ， b , i + 8

    映射后的list i , i + 3 , i + 2 , i + 8

    (先优化至少得在tar中有相同元素，然后再找上升下标) 

    其实这题叶总做法复杂了点，感觉不用f数组，就用g，及时调整最后答案max即可

    再补充一个二分查找的细节，由于我只想把cur放在比他小的中最大的地方，也就是说最后左右边界l和r重合的位置g[l or r]上的数大于等于cur即可，所以如果判断更大要大于等于，小于就是小于

    这类的二分问题与查找某一个结果才行的有区别，该类结果的条件，例如成立的最小坐标x，（0,x）都不成立而[x,∞]都成立，所以再移动左右边界的时候要注意如何缩小到我们的最后求得x


###  747.至少是其他数字两倍的最大数
    模拟题，找出最大和次大，最后比较两者即可


### 264.丑数Ⅱ
    这题可以用优先队列来做，队列中现有一个最小元素1，然后将最小元素x弹出后，再分别将2x,3x,5x入队
    多路归并：
    当最终答案序列arr第一个为1后，剩下的其实我们可以以拿出三个数列来归并
    a2: 1*2 , 2*2 , 3*2 ，5*2.....
    a3: 1*3 , 2*3 , 3*3 ，5*3.....
    a5: 1*5 , 2*5 , 3*5 ，5*5.....

    灵感来源于做法一，丑数序列的后续有之前的数的2,3,5倍数的来，所以
    a2 = 2 * arr
    a3 = 3 * arr
    a5 = 5 * arr
    得到arr的方法就是每次选取三个里面最小的一个加入进去，如果有相同的则一起跳过

### 373.查找和最小的k对数字
    由于num1，num2已经是递增序列，这里多路归并的多路为
    num1[0]+num2[0],num1[0]+num2[1],.....
    num1[1]+num2[0],num1[1]+num2[1],.....
    num1[2]+num2[0],num1[2]+num2[1],.....
    ....
    优化队列（i,j）为num1[i]+num2[j]

    这里有一个优先队列的小优化，我们确保一下num1和num2的相对大小关系（这里num1比num2个数小）
    这里优化的目的是为了让路数，也就是优先队列里面保存的元素个数少，优化空间
    
    //如果k小于n，那么对于有序对（i，j）来说i一定小于k，不会存在比k大的i，这里还可以优化一下空间
    
    但是这里要注意的是如果交换了，最终答案我们的点顺序可能是反的，所以我们需要用一个标记来处理一下
    
### 786.第k个最小的素数分数
    同理对于arr构成的真分数，也可以看作多路的一个归并，类似前面两题，所以这里不在举例子

    代码中含有Arraylist构建方法，还有double类型的比较


### 1716.计算力扣银行的钱
    简单模拟题
    
    补充！优化的模拟

    这里每一周之间其实也是一个等差的关系，所以我们可以直接以周为单位，等差数列求和（最后多的几天也可以单独考虑）


    再这里记录一下别人牛逼(python 乱入)的做法
```python
class Solution:
    def totalMoney(self, n: int) -> int:
        return (div:=n//7) * (div + 7) * 7 // 2 + (1 + (r:=n%7)) * r // 2 + div * r
```
    那就再多写一点，这里python中的海象表达式“：=”

    最基本用法是在运算表达式中插入达到赋值的作用。这里补充一下他的优化性能作用
    
    例如，正常写列表推导式
```python
nums = [16, 36, 49, 64]
def f(x):
    print('运行了函数f(x)1次。')
    return x ** 0.5
print([f(i) for i in nums if f(i) > 5])
```
    上述会运行fx七次（3次成立，4次判断）

    但是如果我们改写，利用：=和一个格外变量

```python
nums = [16, 36, 49, 64]
def f(x):
    print('运行了函数f(x)1次。')
    return x ** 0.5
print([n for i in nums if (n := f(i)) > 5])
```
    这样就会只运行四次

    对于复杂的函数具有较好的优化效果


### 382.链表随机节点
    蓄水池抽样，（洗牌算法）
    从前往后抽取遍历
    重点在于不知道总的数量（链表）
    只需要保证遍历到i个的时候，成为答案的概率为1/i，
    后续遍历如果有成为的，要替换本轮的答案，
    最终所有的样本成为概率就会是1/n
    第一个样本概率为：1*（1/2）*(2/3)*(3/4)*...(n-1/n)=1/n
    第二个样本概率为：（1/2）*(2/3)*(3/4)*...(n-1/n)=1/n
    第三个样本概率为：(1/3)*(3/4)*...(n-1/n)=1/n
    ...

    这个是从前往后，同时不用考虑后续一共有多少个节点

    洗牌算法(经典应用打乱数组384)
    是(1,n),(2,n),(3,n),(4,n)...的范围内两个数字的交换，
    (从前往后选择交换，一个数只能被下标以前的数交换，他最后也只能选择交换到前面的元素)
    其实由于是交换，并没有相对顺序的证明
    ！！再补一下，从前往后只是强调选中的下标，而不要理解成为选择的一个范围，容易证明的时候进入多次交换证明复杂的误区，例如（2，n）范围重要的是在没有被选过的牌中，选择张牌放在2的位置上，与牌原来是否在这里和是否被交换过无关。

    目的是为了得到某一个数字在某一个位置上的概率为1/n，最终得到也是通过这样的一个消掉分式连乘得到的结果

### 1220.统计元音字母序列的数目
    第一种做法，首先可以简单的想到利用动态规划，因为长度每次变化都要根据上一次长度的末尾字符来添加字符，这里省略状态转移方程（看题），可以优化的是只需要上一次状态，所以我们不需要开空间来保存，只需要记录上次状态和当前状态即可

    tips:注意最后转的时候记得int强转的范围，防止溢出
    第二种优化方法，快速矩阵幂

    简单讲一讲就是：对于我们最终答案是由五个状态求和（a,e,i,o,u）
    对于中间的转移过程来说是恒定不变的，相当于是
    (a,e,i,o,u)*mat=(aa,ee,ii,oo,uu)

    长度到n的状态转移其实就是与mat的n-1次幂相乘，这里我们就可以先计算mat的n-1次幂，计算的途中，记得取模，并且利用快速幂（常数相乘）的二分法来达到快速幂运算的效果（这里把（a,e,i,o,u）也化成二维矩阵来看（（a）,（e）,（i）,（o）,（u））可以和mat相乘用一个二维矩阵相乘的函数）

    叶总这次的状态转移其实写的有问题，但是由于结果是转置矩阵，所以最终结果没问题(最后矩阵幂以后和叶总的也成转置关系，由于(a,e,i,o,u)为（1，1，1，1，1）)所以乘上的两个矩阵由于是转置关系，所以最后的得到的向量每一个元素之和显然是相同的（就是矩阵mat中每个元素之和😓）

### 539.最小时间差
    做法一：模拟
    有点类似与我之前做的找点，找夹角，如果将所有夹角简单排序后，一个周期下来，我们无法处理四象限到第一象限的角
    所以我们将角度全部都+2pi，储进遍历数组中,这样一次顺序遍历就可以找到最小夹角（本题的思路一致，相当与多一天的时间也存进去）

    做法二：利用哈斯表计数（桶排序）
    其实就是用一个hash表[24*60*2+10]来存放每个时间点（还有跨天）的次数，如果有一个时间点的个数大于1则就肯定剪枝，最小相邻为0。用一个指针遍历，用另外一个指针指向上一个存在过的时间点。

    这样可以利用常数的时间，不用排序，而且有剪枝（可以直接在统计个数的时候就剪枝了）。

### 219.存在重复元素Ⅱ
    滑动窗口题，在k+1的范围内看是否存在重复元素
    利用set可以实现


### 2029.石子游戏ⅠⅩ
    博弈论
    简述一下规则：
    A先手，B后手，当玩家移除一个石子后，如果总价值为3的倍数，则该玩家输，如果移除完毕后仍然不满足，则B获胜
    
    由于都是最佳抉择，其实就是对棋子的价值量进行分析，由于是三的倍数决胜，我们将棋子分为0,1,2类（求余）。
    s0：不会更改当前已经抽取的余数情况
    s1：如果当前余数为s1,会变成s2，如果s2则会获胜
    s2：同理

    由于s0不会改变抽到的情况（除非全是s0的石子），那A必输，所以大情况我分成s0个数为奇偶。

    为偶数的时候：相当与s0不存在

    如果s1或者s2=0，那么状态一定会在s1 s2交换，无法达成整除,A必败

    如果两个数量不为0，A就可以一开始选择数量不是最多的一方（s1,s2），B也必须选该方，此时A就开始选择更多的，然后B也一直选更少的开始僵持。最后B会先选完自己的，当选对面的时候就是B输的时候

    当s0为奇数的时候，相当于换手，也就是先后手交换：简单的理解就是双方有机会成为交换必胜的一方（之前的操作A其实就是帮B做了）

    但是这个交换只有在对自己必败的情况才会交换

    这里有个简单的翻盘总结：区分点在s1和s2石头数量差距是否达到2

    (这里s1 s2 一方为0的情况是一样的，也只需要考虑两者的差距是否大于2)

    默认假设s1<=s2

    两者相等时，A先手只能选择s1或者s2（假设s1），然后B直接s0，A被迫选择相同选择s1,此时状态s2(s1+s1),s1=s2-2,然后就是B选s2,A选s1的僵持，最后一定是A先选完，然后在B选完s2后状态s1,被迫选择s2输掉
    （s1,s2为0，A只能选s0，直接输）

    两者相差1时，同上的起手
    ①A先手选s1，s1=s2-3，和上情况僵持同理
    ②A先手选s2，s1=s2+1, 同理B能够一直赖在更多的选择上面

    两者相差2时
    ①A先手选s1，略，必输
    ②A先手选s2，此时s1=s2，最后会僵持到s1,s2都被选完，但是由于a后手选最后一个s2，此时A直接输

    两者相差大于2时
    A直接先手选更多的
    ①B此时打出s0，s2-s1>=2,a再选s2，s2-s1>=1，也就是僵持到B选择s2，B输

    ②B不打出s0的话，A可以反手打出s0（确保胜利的法则！！）
    AS2,BS2,AS0,BS1——>此时状态s2，且A打s2,是并且s2的数量一定大于s1，也能逼得B输


### 1345.跳跃游戏Ⅳ

    法一：单向BFS
    由于是为了找最小步数，我们可以BFS来解决，用一个dist[]来保存到每一步的最短步数
    
    同时由于除了前后跳，我们还有等值跳，所以我们另外再建一个map<integer,list[]>储存等值的元素的位置信息（注意由于为了快点到达n-1末尾位置，这里的list记得要倒序遍历构建）

    如果左右跳只要dist[]中不是INF (之前没有被遍历过，就可以入队，并且step+1)

    对于等值跳而言（假设值为t），对于跳到的第一个点而言为step，到达其他的点的步数除非是之前已经前后跳到的步数，否则一定是step+1，并且由于我们是BFS，队列处理，所以一个等值跳可以解决所有等值的dist[]={step,step+1,step+1}所以我们就可以把他们从map中给删掉了(后续无须在处理了)

    其实由于我构建dist的时候就保证了里面的值是最早的到，并且trick为逆序构建list，保证跳的最远，所以正确性也就不证明了

    法二：双向BFS
    （这个可以作为专题训练，后续补上）
    
    
    ！！！！！！防遗忘！！！！！！！

### 1332.删除回文子序列

    题目中说删除的是子序列！！，并且只由AB两个字符组成，所以只有1和2两种答案
    （不存在空串）

    所以如果整个字符串不是回文的话，那么直接一次删所有A一次删所有B即可

### 123.买卖股票的最佳时期Ⅲ

    这里先记录一下从潇晨那里看到的解法
    
    这里对于k的理解我有和他理解冲突的地方
    k我认为应该还是理解为已经操作了的次数更好，不然从前向后转移，剩下次数更多的状态却从剩下更少的状态转移过来我觉得反而有问题

    并且这样处理，一开始无论是k=1,2,3,...max，都用第一个状态处理 buy=-price[0],sell = 0,如果说股票一直在跌，那么其实就是一直不买，或者说，只有一次涨幅的话，就
    dp[i][:][0]最后是一个值。

    上面的想法也证实了对于这种多段问题，其实第二段（后续同理），是先跟着第一次走（也就是说取决于第一次状态的临界最大）然后他才跟着变化

    还要补充的一点就是，这样状态转移方程对于只有一个很大提升的来说，买一次和买两次（同一天卖出和买入其实变化为0）是可以一起解决的

    这样也可以保证最大值一定出现在k=max的时候，这个也是我们降维处理的基础

    dp[i][k][0]//第i天 已经交易了k次 手中没有股票
    dp[i][k][1]//第i天 已经交易了k次 手中有股票
    
    
    // 今天没有持有股票，分为两种情况
    // 1. dp[i - 1][k][0]，昨天没有持有，今天不操作。 
    // 2. dp[i - 1][k][1] + prices[i] 昨天持有，今天卖出，今天手中就没有股票了。
    dp[i][k][0] = Math.max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i])


    // 今天持有股票，分为两种情况：
    // 1.dp[i - 1][k][1] 昨天持有，今天不操作
    // 2.dp[i - 1][k - 1][0] - prices[i] 昨天没有持有，今天买入。
    dp[i][k][1] = Math.max(dp[i - 1][k][1], dp[i - 1][k - 1][0] - prices[i])


### 309.买卖股票的最佳时期含冷冻期

    这里交代一下冷冻期的特别处理手段
    注意这里全部处理为！！该天结束后！！
    这样后不属于有利于多次转移（dp0的状态转移方程）

    # 为当前持有股票
    dp0 = max(`dp0,`dp2-price[i])

    # 改天结束后！！当天卖出了，接下来一天为冷冻期，注意这里不是转移保存状态，他是铁定会卖出的一个状态（真正的判断转移是在dp2上面）

    # 这里边界条件可以理解为当天买入再卖出，所以一开始可以dp1，2都设置为0

    dp1 = `dp0+price[i]
    
    # 该天结束后！！不属于冷冻期,且不持有股票（其实dp2就是冷冻期以及之后的天数）

    dp2 = max(`dp2,`dp1)

    这里已经是降维优化了的，所以记得对于
    dp 和 `dp记得不要复用在一起，因为只取决
    于上一个状态

    最后由于我们不能直接用dp2，因为dp2的更新是要慢一个回合（其实起到了一个延迟周期判断，利用冷冻期再来判断一下，方便dp0的转移）
    dp2来保证了是选择昨天刚刚卖出的收益大，还是不卖收益大。

    由于最后一天没有冷冻期给你判断，所以最终返回结果必须是max(dp1,dp2)
    
    举个例子（最后一个回合可以卖出换的利润）

### 2034.股票价格波动

    这里学习一下java新的数据结构
    红黑树TreeMap<int,int>,本题作用是会根据KEY值升序排序，方便我们获得最高最低股价

    这里用hashmap储存<时间，价格
    >
    用treemap储存<价格，次数>
    
    哈希map的作用简单易懂，treemap相当于查询和排序的一个数据结构（学到了）

    这里储存的时候hash表更新简单，对于红黑树需要把old值去掉或者cnt-1（红黑树也有唯一key值得特性，所以对于cnt>1可以直接更新cnt-1）
    

### 2045.到达目的地的第二短时间
    正权无向图求路径
    并且边的数量较少，所以我们可以用dij和优先堆优化来得到此段路径
    
    用两个数组dist1,dist2分别保存最短路径和严格次短路径。这里我们在一开始避免每次都开数组，直接static，然后每次重置
    
    更新的方法其实类似于其他次短路径更新（详细看代码）

    由于可以重复经过，这里不用记录已经走过的边，只是需要在更新的时候进行入堆操作

    这里由于又红绿灯的存在，所以我们要加入动态权边
    当 step/change = 奇数的时候，停在红灯上，下一步需要走的时间为
    time + change - step % change (time后面为动态权边)

    老实说叶总代码这个可读性不是很强，有些具体解释我还是写在代码注释里面吧。

    由于注释已经写了，所以后面被注释掉的反而是BFS优化代码嘻嘻

    第一个不一样就是dist1,2数组变成了每次重新开辟，且大小n+10,(10为常数，因为我们还是按照节点的表数为准，所以我们0下标不用，从下标1开始)

    其实也没感觉有多bfs，哦也有，由于所有点他红绿灯的情况是一样的，所以我们对于走过多少条边（无论有无暂停，因为必须立刻走或者红灯了也立刻离开）所以我们走的边越少（并且路径可以确定）其实我们就越快，所以我们可以先将图里面的所有边权值设为1，先用正常的dij bfs来解决（当然和法一一样会使用稀疏扫图）

    最后我们会获得次dist的时间花费（其实就是经过边数？步数），然后我们再来每一步乘上time，并且每一步是否红灯情况在考虑，最后答案累加成的ans即为答案

    这里更新dist1,2的时候注意，q中弹出的dist变量由于没有像法一一样动态权值，所以比较或者变化的时候dist+1才是走到临接点的步数。

    明天记得解决一下叶总的建图🧀743
    https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247488007&idx=1&sn=9d0dcfdf475168d26a5a4bd6fcd3505d&chksm=fd9cb918caeb300e1c8844583db5c5318a89e60d8d552747ff8c2256910d32acd9013c93058f&token=211780171&lang=zh_CN#rd
    (做完再删)

### 743.网络延迟空间
    嗄，其实挺简单一个题，也就是dij可以做

    那就其实顺便当作复习一下邻接表吧（邻接矩阵用的确实比较多了）

    

### 1688.比赛中的配对次数
    每场比赛淘汰1人，最后一个赢家（（（那肯定是比n-1场

    这里叶总还请我们两道全鱼宴，747在上面

    1716 更新了优化方法


### 2013.检测正方形
    add操作中，学习一下哈希表套哈希表
    （显然在网格大小确定并且不够大的时候，模拟统计用数组储存点的信息也是可以的，但是这里用哈希表就可以动态插入，不用考虑表的范围大小）
    可以制作动态的一个表储存复数个点个数
    map:{x, {y : 点 (x,y) 数量}}

    point 以x为基准，找不同的y值（c1），确定边长，然后再图里面找到正方形水平方向平行的两个点存在个数（c2,c3），c1*c2*c3就是组合形成正方形的个数（这里貌似point的点只看成一个）

### 2047.句子中的有效单词数
    字符串模拟题，用个check来统计
    （叶总最后那个标点符号多判断了一个数量，其实只用判断是否在末尾就行了）
    
### 1996.游戏中弱角色的数量

    两个属性的比较问题

    弱角色需要存在二维数组中两个属性都比它严格大于的存在（ps[0],ps[1]）

    这里考虑比较的时候可以先比ps[0],再比ps[1]
    所以我们想到了按照ps[0]优先降序排序，如果相同的话然后再ps[1]升序排序。

    显然可能会存在同一攻击力，防御力不同的情况，我们如何比较呢？（非常简单的问题）

    对于某一个攻击力的“族群”来说，只要他不是最大攻击力的族群i=0，那么攻击力就一定有严格大于他的存在，此时我们只需要保证攻击力大于它的族群里面存在一个的防御值严格大于它，此时这个防御值显然是需要并且动态更新的（不断贪心选择最大的，当一个族群遍历完了之后，再更新当前最大值——>因为需要攻击力也要严格大于，同一个攻击力的之间是不会影响弱角色判断的，只会影响下一个严格低于的攻击力族群）

    这里也有个小想法，既然max最后更新，每次也要比较，cur直接比较同一族群防御力最高的再更新是不是就可以了

    
### 1765.地图中的最高点
    相邻格子高度差最多为1，找能够构建最高地的height图，其实相当于找到离水源地最远的一条路径，满足了bfs的想法

    这里一个图有多个水源，也就可以看作多个次起点（我们假设一个虚拟起点在图外，邻接这些次起点）问题转化为一个多源BFS的问题来解决

    多元BFS的遍历处理的时候，例如该题，需要保证节点更新的深度是同一的，比如第一次队列里面深度全部都是0，第一波bfs更新的节点深度显然为1，入队后我们分开一个循环，将他们新入队的节点设在深度1的循环，再开始bfs,简单来说就是多源的情况下，利用每次循环当前队列里面的个数，来作为一个控制循环批次的条件，保证当前循环更新的深度统一得到保障
    （这题感觉不是刚需，也可以一直入队出队）


    初始化的时候将ans矩阵水源设为0，并且全部入队，陆地设为-1，便于判断该陆地是否已经被别的BFS的遍历到了（题目给的水域陆地水域是1。。。。差点还搞混）


### 884.两句话中的不常见词
    简单模拟，哈希表操作一下就行了


### 1763.最长的美好子字符串
    基础的做法是前缀和优化
    这里默认开128
    （理论远超26+26）

    最后一个n方的遍历，看字符词频的数量是否满足即可

    二进制优化，有点屌，我们用两个int 即可记录两个26位信息是否出现

    大小写都要出现的话也只有a，b这两个int相同的时候才满足

    这个二进制的优化标记真的很值得学习

### 1342.将数字变成0的操作次数
    我一来也想到的是数学做法，把这个数看成是二进制数（怎么感觉这么怪，可能就是十进制数带来的坏习惯吧），那么显然操作次数就是n的二进制位数和1的个数之和(-1)
    这里显然最前面的那个1直接消去，但是不用位移

    int 32位，所以我们直接从让n位移从多到少就可以知道有多少位了

    知道位数后再用1 求并，得到1的个数


### 2000.反转单词前缀
    就简简单单找到位置用一下index函数，然后反转就行了


### 1414.和为K的最少斐波拉契数
    这个做题其实蛮好想得，斐波拉契数是有更小的斐波拉契数构成，无论是多少，如果能选大的，绝不选小的，因为大的一定可以由更小的组成，并且需要的数量更多。
    显然这里就存在一个贪心策略，要选择不大于k的最大的斐波拉契数，然后对于剩下的差值，重复这样的步骤（注意这里可以重复选择一个数）


### 1725.可以形成最大正方形的个数
    简单模拟题，不要想复杂了就好


### 1219.黄金矿工
    回溯dfs搜索，相当于把他所有的点当作起点进行DFS搜索

    回溯的一个关键是记忆要回溯，就是操作完成后要复原，其实这个也简单理解，就是把visited置为false和true的转换，这样就可以复原。

    其实做到这里的时候我想过两个优化（但是又不行）

    ①理论来说，如果一个点已经被搜索过了，那么应该不用再接着这个点继续搜索了，应该可以保存这个结果，在DFS的时候返回


    ×！！这样不行，因为这样很可能会返回重复经历某一个点的值，可能会导致挖矿的路径形成一个圈

    ②这个不一定了，就是大部分的最长出发点应该在边界，或者是四个角，但是我想了一想，也有可能是中间有一坨旋转的贪吃蛇，没有在边界，所以这个做法值得考究。


### 1748.唯一元素的和
    从数据量看出用哈希表比较好
    （一路copilot tab工程师实锤）
    （今早起来有🐱🐱）

### 1405.最长快乐字符串
    由于不能让三个字符串在一起，这里其实我们肯定也能想到优先选择最多的先放，如果已经满足两个了，就选择次多的，这样就可以保证每个字符串都能放下去。
    
    （显然对于剩下的字符来说，如果剩下的个数逼近a=b=c，则后续能放的更长，如果剩下某一个特别多，则很容易放不下去，超出三个连续的限制）