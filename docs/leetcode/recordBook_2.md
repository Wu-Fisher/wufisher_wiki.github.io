# Wufisher recordBook_2

thank ac_oier

update 2022/3/7  not catch

### 1001.网格照明 hard 2/8

    题目给的数据：网格范围高达1e9，如果直接硬遍历肯定会超时，但是由于我们发现灯的数量和查询数量只有e4级别，较小，所以我们就采用hash映射来解决稀疏的问题；

    hashmap 4个，分别记录col，row，left，right，每个hashmap的key是灯的位置，value是灯的状态，0表示灯灭，1表示灯亮；

    这里的Left 和 right 分别是左右对角线，映射key值为坐标x+y(x-y)非常巧妙。

    hashmap的value值为这里灯覆盖的层数，很好理解，比如一个灯灭了之后，只是他这个灯影响的光灭了，如果这个格子被其他灯照亮，则不会影响。


    然后再用一个hashset记录灯的位置，这里我们采用 x*n+y 转化为一维的形式记录来减小空间

    有趣的一点是，这个题查询后，只灭灯！！！，不灭光。（不过显然如果一个灯灭了，也会造成影响）


### 2006.差的绝对值为K的数对数目 easy 2/9

    数据范围小，也可以直接简单模拟统计

    优化的话用hash表统计数频，再计算数频差值的同时，更新hash表，便于后续比较


### 1447.最简分数 middle 2/10 
    这题由于n的数据量比较小，所以可以考虑枚举的方法

    所以问题转化为判断分数是否是最简分数->公约数是否为1

    这里学了两个求公约数的方法
    1.更相减损法：这个是需要实现高精度的时候适用

    ♥2.欧几里得算法：这个用递归很好写
    这里无需考虑判断 ab是否为0以及相对大小问题（这个其实看看递归是怎么写的就看出来了）

    int gcd(int a, int b) { // 欧几里得算法
        return b == 0 ? a : gcd(b, a % b);
    }






### 1984.学生分数的最小差值 easy 2/11


    排序之后，使用窗口长度为k的进行滑动（数据处理后的模拟一遍，就可以得到答案）

    这个ans默认不能一开始（哦不对好像也可以，- -
    ，哎就把这个留在这里作为对于简单题的反思吧）



### 1020.飞地的数量 middle 2/12

    这次我还是大致方向想对了，利用dfs和并查集

    （后补，其实我想的应该是多源BFS）
    其实这里更像是一个图论的深化吧，利用连通分量的一些性质，后面我写的三个函数也都是在处理找联通分量可以复用的函数

    1：从边界外的超级源点0开始连接着边界的陆地节点开始dfs
    2：并查集针对每一个陆地节点，简单来向就是，如果这个节点在之前的dfs中被搜到过，就加以标记，如果再次搜到，就跳过（显然那个点以及后续以及被操作搜索过了）

    **这里把每个点的标记x*N+y在一维进行标记
    **这里的N为n（矩阵宽度），没有什么特殊的处理，就是射在一维上（这么想来其实二位矩阵也没问题）

    老实说一开始没看懂叶总的题解代码，写一遍记录一下吧

    🐎核心来哩！，这个题里面的并查集不是简单的搜索过了，而是先把每个点标记为一个单独的联通分量

    union 将两个点编号连接起来
    find  查找该点属于哪一个联通分量
    query 判断两个点是否为一个联通分量


    🐱后面看了叶总第二个BFS感觉才像是我想到的做法，多源BFS，从边界陆地起点开始搜索，凡是能搜索到（出入队）的都是能够访问的节点。这里就用一个二维的vis来记录节点是否被访问过，访问过的也不用再次入队。

    最后再遍历即可得到没有被访问过的陆地节点个数

    ！！！做到这里我也得加一个任务
        ：把题型中可以复用的函数要拿出来记录一下


### 1189.气球的最大数量 easy 2/13   
    简单模拟统计一下词频就好，注意有两个字符的需要两个（统计时除以2）

### 540.有序数组中的单一元素 middle 2/14

    要求时间复杂度logn，那肯定要二分了，但是一开始我也没想到怎么常规的二分，后来看了叶总的脑筋急转弯思路大开。

    正常来说两个相同的数字同时出现，则一个数字在奇数位置，一个数字在偶数位置。当出现了单一元素后，则会发生数字的调换。

    🐎这里奇偶位置是一个相对关系：
    这样解释比较好，当你查到一个数的时候，如果该位置是偶数（数组下标从偶数0开始而不是奇数1），那么在单一位置前，应该查后面（偶数位置）一个数应该是相同的。
    当在单一数位置后则相反。我们便利用这个性质来调查二分。

    还是得注意一下二分法的一个状态判断，一般来说mid=l+r>>1，且mid可能为最后落脚点的 l = mid+1 || r = mid;(提醒合理选取二分边界的控制)

### 1308.矩阵中的幸运数 easy 2/15
    简单模拟一下，遍历记录一下


### 1719.重构一棵树的方案数 hard 2/16

    太苦难勒，过阵子再来补，今天早上属实是头疼了
    
    偷了一下网友的代码


### 688.骑士在棋盘上的概率 middle 2/17

    dp题，利用动态规划
    f[i][j][k]为从位置i,j出发，当前使用步数不超过k步，仍然在棋盘内的概率

    这里我们并不是从row,colum位置开始更新，而是对每一步，棋盘上的每一个点进行更新。
    f[i][j][p]=∑f[nx][ny][p−1]/8

    一开始我还没搞懂，为什么移动后的nx,ny反而变成了转移前的状态，关键就在于我们的f定义，是nx,ny为出发位置的概率。

    这里就可以相当于，我们从x,y出发，剩余k步，我们有1/8的概率走到nx，ny八个方向上，然后从nx,ny出发，有k-1个移动步数。此时这样就能理解上面的转移求和公式了

### 1791.找出星型图的中心 easy 2/18
    
    这题属于是特殊easy题了，- -
    直接两条边就能确定中心了
    这个中心就是真的中心（不是啥图论概念）


### 969.煎饼排序 middle 2/19

    这题的煎饼排序虽然是对0,k-1的翻转，但是并不是一种排序算法，只是一种操作手段。（本质上我们还是要用学过的排序算法来解决问题）

    这里是对前缀进行翻转，那么我们也可以想到用冒泡排序来解决问题。（每次决定最右端的值）

    那么我们如何把x放在我们想要他在的k-1位置上呢？（由于我们采用的是冒泡排序，k+1,n-1为有序递增段落）

    如果x在k-1上，则不做操作

    如果x在0上，则一次反转可以达到

    如果x在idx上（0<idx<k-1），则先（0，idx）反转，然后再转到上一个情况反转一次即可

    这里显然每个数到某一个位置只需要2次操作（由于只对前缀进行变换，不会影响后缀已经排序好的数）

    👆满足了我们所需要的少于10*array.length次操作要求。

    arr 是从 1 到 arr.length 整数的一个排列。题目如此要求，显然我们可以用一个idx[n+10]的数组来记录每个数的位置，方便我们排序使用。

### 717.1比特与2比特字符 easy 2/20

    由于1比特 0 
    2比特是10 或者11

    可以看出如果对于没有选择的话，遍历遇到的第一个为1，则只能2比特，如果遇到的是0，则只能1比特。

    然后根据情况模拟就ok

### 838.推多米诺 middle 2/21
    法一：BFS

    队伍元素（loc,time,dir）位置，时间，导向的方向。这里的BFS显然就是对于所有一开始推倒的点，按照时间为层数（第一秒为第一层，全部遍历，第二秒为第二层，全部遍历）

    这样罗列出来就可以看出可以操作每一个时间所有多米诺骨牌的变化。

    细节在于：通过另外一个数组记录他上一次发生偏倒的时间（由于多米诺骨牌和更新队列的性质，如果一个点两次🐎同时🐎被施力一定是同时收到了两个力）则可以修改当前点的结果为.（不偏倒）

    这里也同时通过这个受力时间可以判断加入两个同方向的牌开始推倒，如果后面追赶的遍到前面已经倒下的牌的时间与追到时间不一致，则前面的已经倒下，就没必要再继续推倒遍历了。

    法二：预处理+双指针

    利用两个数组[][]l和[][]r，分别记录每个点左右侧最近受力点下标和方向

    避免每个样例开新数组，这里l和r用static修饰一下。

    主要操作点在连续的'.'段上，具体操作还是看代码吧，注释写在里面。感觉这个方法没有法一通解性。


### 1994.好子集的数目 hard 2/22


    叶总说是完全NP（NPC）问题，所以无法多项式解决，只能暴搜+剪枝，或者状压dp。（其实有点没理解，后续再补充研究np）

    应该就是无法从题目本身得到一个解，而是我们能够通过遍历验证所有情况，通过🐎验证的方式得到解的一个多项式时间复杂度。
    这里我们就把考虑2到30所有的数情况都带进去验证（依托他nums中数字的频率）

    漱口的时候突然想通了，或许npc就是一个通法问题，重点在于时间复杂度和方法取自能够对所有该类问题的输入验证他的答案。加入了条件判断，以及本身他是否存在词频是否为0来加快遍历。其实把2-30的所有state都验证了一遍，也就的到了O（1024*30+n）的一个标准时间复杂度。

    NPC问题还是一个核心在于对该类问题的强大通解性，无输入出发性，还有对所有可能的一个考虑性（即使他的输入词频某数为0，也要纳入遍历考虑）
    
    NPC问题：NP中的某些问题的复杂性与整个类的复杂性相关联.这些问题中任何一个如果存在多项式时间的算法,那么所有NP问题都是多项式时间可解的.这些问题被称为NP-完全问题(NPC问题)。

    题目数值30以下（一共有十个质数）且每一个好子集里面只能出现一次。

    由于题目对于相同定义取自下标，所以我们可以用cnts保存nums中每个数字出现的次数，最后得到次数的时候可以使用

    显然能够使用的数字有限，所以我们用二进制数来储存最后子集能够拆解成那些质数（位置为1）p[i]=1为能被拆解为p[i](p[]为30以下的质数合集)

    f[state]为当前状态拆解结果用到质数为state的方案数目

    f[0]=1,并且我们对子集的乘积进行质数分解，相当于对子集的每一位数进行质数分解

    好了看了一遍代码理清楚了：

    dp的地方是从2——30考虑每一个数加入（递增）的影响（由于我会统计数频，以及该数本身的state情况）总之就是需要这个数本身能够作为一个子集，才能可能和其他子集构建新的子集。
    （这是一个验证问题，就np问题了）

    然后再挨个状态转移的时候，我们选择的是递减的枚举state状态QA：因为不难想到我们希望更新的是 cur并上不包含该数t但是却可以容纳cur进入该子集的状态

    👆突然就有问题了，由于我能找到的都是不同的相容状态，再按照状态转移的或运算后肯定不会出现本轮状态转移之前就改动的情况，理论来说好像递增递减都可以

    确实可以，又找到叶总的一个小问题👌

    最后还有一个对1的特殊处理，1不影响乘积，所以对于不同下标的1都可以看作一个二的幂次状态，最后处理一下ans。


### 917.仅仅反转字母 easy 2/23

    左右双指针，分别指向可以反转的位置（字母非字符），然后反转即可


### 1706.球会落何处 middle 2/24

    由于数据范围100，直接对每个球进行模拟即可。

    球能够滚下去（x,y）->(x+g[x],y+1) 
    
    g[x+g[x],y]=g[x,y]才能顺着下去，否则会在v里面被卡住。

    显然也还有边界条件


### 👴⚪狂摸，接下要是要补进度的哩

### 564.寻找最近的回文数 hard 3/2

    给定字符串，返回与他绝对值差最小的那个（如果有两个优先返回较小的）

    如果单纯的找最近的数字，我们的想法肯定是从最低位置开始改变，但是由于这个是回文字符串，对于abcde而言，改动e也会改动a，变化就大了，所以我们更倾向于改动c,（对于abcd）而言就是改动bc

    由于回文数的定义，我们只需要管理前面一半，abc即可

    可能是abc,abc+1,abc-1（为前缀产生的回文串）都是最近的可能存在

    但是对于临界进退位值来说，确实可能要考虑边界的问题：
    例子 abc=999,100
    得到的 1000001 和 999
    但实际确实 10001 和 9999 更靠近

    所以我们再接着考虑 10^n-1 -1 和 10^n +1 从上面例子也可以得出这个选择（也只有边界这类似的条件才会影响长度，并且截断）

    注意生成串的时候考虑串的奇偶性质

    还要注意不包含自身


### 2016.增量元素之间的最大差值 easy 2/25

    简单模拟题，两个指针，因为要求i<j ,差值=num[j]-num[i],既同时判断更新最大差值，又同时更新最小的min(这个min只能被后面的减，所以这里遍历的时候同步更新就好)


### 537.复数乘法 middle 2/26

    简单模拟，字符串分割即可，按照乘法定义计算

### 258.各位相加 easy 3/3

    一直把各位相加，直到为一个位数

    对于num而言，把他拆成各项10次幂的多项式，然后把每个次幂的基数10-1=9，就可以分出本次计算一项各项和的项。

    然后我们就可以对他做文章了

    因为9是三的倍数，显然很多性质可以传递，比如各项和相加为9的倍数，该数字为9的倍数。

    🐎我们直接对num求9的模，其实也是在对他的各项和求模。每次都会把各项和拆在左边，越来越小的同时会逼近个位数。

    这里有个特殊点就在于num如果为9的倍数，则9会被拆到左边大项里面去化0，显然是不对的，所以我们需要单独拎出来

    当然如果用%判断倍数，则要考虑0，所以又单独拿出来判断


### 2104.子数组范围和 easy 3/4

    显然直接模拟tle

    dp时间空间都非常的庸俗（注释贴后面吧）

    记录一下单调栈的做法：

    🐎单调栈的作用是：
    递增递减取决于弹出栈后的顺序

    入栈的要求是要求元素大于或者小于栈顶元素

    tips:方便判断可以加入哨兵-1等用于优化可能取出栈中所有元素

    
    

    

### 521.最长特殊序列Ⅰ easy 3/5

    脑经急转弯，如果两个子符串不相同（不是长度），那么显然更长的字符串的本身一定不包含在更短字符串的子集里面，显然就是最长特殊，如果相同那么就不存在-1；
    

### 2100.适合打劫的日子 middle 3/6

    前缀和问题

    打劫的日子，简单的一个缩小范围，根据题意，时间肯定在[time,n-time]内，并且要求左非递增，右非递减

    首先维护一个数组[]g，g[i]记录s[i]与s[i-1]的关系，如果递增则为1，递减为-1，不变为0；

    随后分别用[]a,[]b记录时间i之前1和-1的数量

    那么对于时间i，如果a[i]-a[i-time]==0,b[i+time]-b[i]==0,则可以打劫

    注意这里时间和下标的问题，叶总的ab数组的下标从1到n，我这里就选择0到n-1和原始天数对应。



### 504.七进制数 easy 3/7

    简单模拟题

    有点需要注意的就是，构建转换的顺序问题，以及该题需要考虑一下负数的转换，记得判断一下