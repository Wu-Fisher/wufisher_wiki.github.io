# Wufisher recordBook_2

thank ac_oier

update 2022/3/10 updated 798困难题第一次感觉很牛逼

决定更新第三部，更新一下写法


### 1001.网格照明 hard 2/8

    题目给的数据：网格范围高达1e9，如果直接硬遍历肯定会超时，但是由于我们发现灯的数量和查询数量只有e4级别，较小，所以我们就采用hash映射来解决稀疏的问题；

    hashmap 4个，分别记录col，row，left，right，每个hashmap的key是灯的位置，value是灯的状态，0表示灯灭，1表示灯亮；

    这里的Left 和 right 分别是左右对角线，映射key值为坐标x+y(x-y)非常巧妙。

    hashmap的value值为这里灯覆盖的层数，很好理解，比如一个灯灭了之后，只是他这个灯影响的光灭了，如果这个格子被其他灯照亮，则不会影响。


    然后再用一个hashset记录灯的位置，这里我们采用 x*n+y 转化为一维的形式记录来减小空间

    有趣的一点是，这个题查询后，只灭灯！！！，不灭光。（不过显然如果一个灯灭了，也会造成影响）


### 2006.差的绝对值为K的数对数目 easy 2/9

    数据范围小，也可以直接简单模拟统计

    优化的话用hash表统计数频，再计算数频差值的同时，更新hash表，便于后续比较


### 1447.最简分数 middle 2/10 
    这题由于n的数据量比较小，所以可以考虑枚举的方法

    所以问题转化为判断分数是否是最简分数->公约数是否为1

    这里学了两个求公约数的方法
    1.更相减损法：这个是需要实现高精度的时候适用

    ♥2.欧几里得算法：这个用递归很好写
    这里无需考虑判断 ab是否为0以及相对大小问题（这个其实看看递归是怎么写的就看出来了）

    int gcd(int a, int b) { // 欧几里得算法
        return b == 0 ? a : gcd(b, a % b);
    }






### 1984.学生分数的最小差值 easy 2/11


    排序之后，使用窗口长度为k的进行滑动（数据处理后的模拟一遍，就可以得到答案）

    这个ans默认不能一开始（哦不对好像也可以，- -
    ，哎就把这个留在这里作为对于简单题的反思吧）



### 1020.飞地的数量 middle 2/12

    这次我还是大致方向想对了，利用dfs和并查集

    （后补，其实我想的应该是多源BFS）
    其实这里更像是一个图论的深化吧，利用连通分量的一些性质，后面我写的三个函数也都是在处理找联通分量可以复用的函数

    1：从边界外的超级源点0开始连接着边界的陆地节点开始dfs
    2：并查集针对每一个陆地节点，简单来向就是，如果这个节点在之前的dfs中被搜到过，就加以标记，如果再次搜到，就跳过（显然那个点以及后续以及被操作搜索过了）

    **这里把每个点的标记x*N+y在一维进行标记
    **这里的N为n（矩阵宽度），没有什么特殊的处理，就是射在一维上（这么想来其实二位矩阵也没问题）

    老实说一开始没看懂叶总的题解代码，写一遍记录一下吧

    🐎核心来哩！，这个题里面的并查集不是简单的搜索过了，而是先把每个点标记为一个单独的联通分量

    union 将两个点编号连接起来
    find  查找该点属于哪一个联通分量
    query 判断两个点是否为一个联通分量


    🐱后面看了叶总第二个BFS感觉才像是我想到的做法，多源BFS，从边界陆地起点开始搜索，凡是能搜索到（出入队）的都是能够访问的节点。这里就用一个二维的vis来记录节点是否被访问过，访问过的也不用再次入队。

    最后再遍历即可得到没有被访问过的陆地节点个数

    ！！！做到这里我也得加一个任务
        ：把题型中可以复用的函数要拿出来记录一下


### 1189.气球的最大数量 easy 2/13   
    简单模拟统计一下词频就好，注意有两个字符的需要两个（统计时除以2）

### 540.有序数组中的单一元素 middle 2/14

    要求时间复杂度logn，那肯定要二分了，但是一开始我也没想到怎么常规的二分，后来看了叶总的脑筋急转弯思路大开。

    正常来说两个相同的数字同时出现，则一个数字在奇数位置，一个数字在偶数位置。当出现了单一元素后，则会发生数字的调换。

    🐎这里奇偶位置是一个相对关系：
    这样解释比较好，当你查到一个数的时候，如果该位置是偶数（数组下标从偶数0开始而不是奇数1），那么在单一位置前，应该查后面（偶数位置）一个数应该是相同的。
    当在单一数位置后则相反。我们便利用这个性质来调查二分。

    还是得注意一下二分法的一个状态判断，一般来说mid=l+r>>1，且mid可能为最后落脚点的 l = mid+1 || r = mid;(提醒合理选取二分边界的控制)

### 1308.矩阵中的幸运数 easy 2/15
    简单模拟一下，遍历记录一下


### 1719.重构一棵树的方案数 hard 2/16

    太苦难勒，过阵子再来补，今天早上属实是头疼了
    
    偷了一下网友的代码


### 688.骑士在棋盘上的概率 middle 2/17

    dp题，利用动态规划
    f[i][j][k]为从位置i,j出发，当前使用步数不超过k步，仍然在棋盘内的概率

    这里我们并不是从row,colum位置开始更新，而是对每一步，棋盘上的每一个点进行更新。
    f[i][j][p]=∑f[nx][ny][p−1]/8

    一开始我还没搞懂，为什么移动后的nx,ny反而变成了转移前的状态，关键就在于我们的f定义，是nx,ny为出发位置的概率。

    这里就可以相当于，我们从x,y出发，剩余k步，我们有1/8的概率走到nx，ny八个方向上，然后从nx,ny出发，有k-1个移动步数。此时这样就能理解上面的转移求和公式了

### 1791.找出星型图的中心 easy 2/18
    
    这题属于是特殊easy题了，- -
    直接两条边就能确定中心了
    这个中心就是真的中心（不是啥图论概念）


### 969.煎饼排序 middle 2/19

    这题的煎饼排序虽然是对0,k-1的翻转，但是并不是一种排序算法，只是一种操作手段。（本质上我们还是要用学过的排序算法来解决问题）

    这里是对前缀进行翻转，那么我们也可以想到用冒泡排序来解决问题。（每次决定最右端的值）

    那么我们如何把x放在我们想要他在的k-1位置上呢？（由于我们采用的是冒泡排序，k+1,n-1为有序递增段落）

    如果x在k-1上，则不做操作

    如果x在0上，则一次反转可以达到

    如果x在idx上（0<idx<k-1），则先（0，idx）反转，然后再转到上一个情况反转一次即可

    这里显然每个数到某一个位置只需要2次操作（由于只对前缀进行变换，不会影响后缀已经排序好的数）

    👆满足了我们所需要的少于10*array.length次操作要求。

    arr 是从 1 到 arr.length 整数的一个排列。题目如此要求，显然我们可以用一个idx[n+10]的数组来记录每个数的位置，方便我们排序使用。

### 717.1比特与2比特字符 easy 2/20

    由于1比特 0 
    2比特是10 或者11

    可以看出如果对于没有选择的话，遍历遇到的第一个为1，则只能2比特，如果遇到的是0，则只能1比特。

    然后根据情况模拟就ok

### 838.推多米诺 middle 2/21
    法一：BFS

    队伍元素（loc,time,dir）位置，时间，导向的方向。这里的BFS显然就是对于所有一开始推倒的点，按照时间为层数（第一秒为第一层，全部遍历，第二秒为第二层，全部遍历）

    这样罗列出来就可以看出可以操作每一个时间所有多米诺骨牌的变化。

    细节在于：通过另外一个数组记录他上一次发生偏倒的时间（由于多米诺骨牌和更新队列的性质，如果一个点两次🐎同时🐎被施力一定是同时收到了两个力）则可以修改当前点的结果为.（不偏倒）

    这里也同时通过这个受力时间可以判断加入两个同方向的牌开始推倒，如果后面追赶的遍到前面已经倒下的牌的时间与追到时间不一致，则前面的已经倒下，就没必要再继续推倒遍历了。

    法二：预处理+双指针

    利用两个数组[][]l和[][]r，分别记录每个点左右侧最近受力点下标和方向

    避免每个样例开新数组，这里l和r用static修饰一下。

    主要操作点在连续的'.'段上，具体操作还是看代码吧，注释写在里面。感觉这个方法没有法一通解性。


### 1994.好子集的数目 hard 2/22


    叶总说是完全NP（NPC）问题，所以无法多项式解决，只能暴搜+剪枝，或者状压dp。（其实有点没理解，后续再补充研究np）

    应该就是无法从题目本身得到一个解，而是我们能够通过遍历验证所有情况，通过🐎验证的方式得到解的一个多项式时间复杂度。
    这里我们就把考虑2到30所有的数情况都带进去验证（依托他nums中数字的频率）

    漱口的时候突然想通了，或许npc就是一个通法问题，重点在于时间复杂度和方法取自能够对所有该类问题的输入验证他的答案。加入了条件判断，以及本身他是否存在词频是否为0来加快遍历。其实把2-30的所有state都验证了一遍，也就的到了O（1024*30+n）的一个标准时间复杂度。

    NPC问题还是一个核心在于对该类问题的强大通解性，无输入出发性，还有对所有可能的一个考虑性（即使他的输入词频某数为0，也要纳入遍历考虑）
    
    NPC问题：NP中的某些问题的复杂性与整个类的复杂性相关联.这些问题中任何一个如果存在多项式时间的算法,那么所有NP问题都是多项式时间可解的.这些问题被称为NP-完全问题(NPC问题)。

    题目数值30以下（一共有十个质数）且每一个好子集里面只能出现一次。

    由于题目对于相同定义取自下标，所以我们可以用cnts保存nums中每个数字出现的次数，最后得到次数的时候可以使用

    显然能够使用的数字有限，所以我们用二进制数来储存最后子集能够拆解成那些质数（位置为1）p[i]=1为能被拆解为p[i](p[]为30以下的质数合集)

    f[state]为当前状态拆解结果用到质数为state的方案数目

    f[0]=1,并且我们对子集的乘积进行质数分解，相当于对子集的每一位数进行质数分解

    好了看了一遍代码理清楚了：

    dp的地方是从2——30考虑每一个数加入（递增）的影响（由于我会统计数频，以及该数本身的state情况）总之就是需要这个数本身能够作为一个子集，才能可能和其他子集构建新的子集。
    （这是一个验证问题，就np问题了）

    然后再挨个状态转移的时候，我们选择的是递减的枚举state状态QA：因为不难想到我们希望更新的是 cur并上不包含该数t但是却可以容纳cur进入该子集的状态

    👆突然就有问题了，由于我能找到的都是不同的相容状态，再按照状态转移的或运算后肯定不会出现本轮状态转移之前就改动的情况，理论来说好像递增递减都可以

    确实可以，又找到叶总的一个小问题👌

    最后还有一个对1的特殊处理，1不影响乘积，所以对于不同下标的1都可以看作一个二的幂次状态，最后处理一下ans。


### 917.仅仅反转字母 easy 2/23

    左右双指针，分别指向可以反转的位置（字母非字符），然后反转即可


### 1706.球会落何处 middle 2/24

    由于数据范围100，直接对每个球进行模拟即可。

    球能够滚下去（x,y）->(x+g[x],y+1) 
    
    g[x+g[x],y]=g[x,y]才能顺着下去，否则会在v里面被卡住。

    显然也还有边界条件


### 👴⚪狂摸，接下要是要补进度的哩

### 564.寻找最近的回文数 hard 3/2

    给定字符串，返回与他绝对值差最小的那个（如果有两个优先返回较小的）

    如果单纯的找最近的数字，我们的想法肯定是从最低位置开始改变，但是由于这个是回文字符串，对于abcde而言，改动e也会改动a，变化就大了，所以我们更倾向于改动c,（对于abcd）而言就是改动bc

    由于回文数的定义，我们只需要管理前面一半，abc即可

    可能是abc,abc+1,abc-1（为前缀产生的回文串）都是最近的可能存在

    但是对于临界进退位值来说，确实可能要考虑边界的问题：
    例子 abc=999,100
    得到的 1000001 和 999
    但实际确实 10001 和 9999 更靠近

    所以我们再接着考虑 10^n-1 -1 和 10^n +1 从上面例子也可以得出这个选择（也只有边界这类似的条件才会影响长度，并且截断）

    注意生成串的时候考虑串的奇偶性质

    还要注意不包含自身


### 2016.增量元素之间的最大差值 easy 2/25

    简单模拟题，两个指针，因为要求i<j ,差值=num[j]-num[i],

    既同时判断更新最大差值，又同时更新最小的min
    (这个min只能被后面的减，所以这里遍历的时候同步更新就好)


### 537.复数乘法 middle 2/26

    简单模拟，字符串分割即可，按照乘法定义计算
    
    代码里面还有一些正则表达式的知识

### 258.各位相加 easy 3/3

    一直把各位相加，直到为一个位数

    对于num而言，把他拆成各项10次幂的多项式，然后把每个次幂的基数10-1=9，就可以分出本次计算一项各项和的项。

    然后我们就可以对他做文章了

    因为9是三的倍数，显然很多性质可以传递，比如各项和相加为9的倍数，该数字为9的倍数。

    🐎我们直接对num求9的模，其实也是在对他的各项和求模。每次都会把各项和拆在左边，越来越小的同时会逼近个位数。

    这里有个特殊点就在于num如果为9的倍数，则9会被拆到左边大项里面去化0，显然是不对的，所以我们需要单独拎出来

    当然如果用%判断倍数，则要考虑0，所以又单独拿出来判断


### 2104.子数组范围和 easy 3/4

    显然直接模拟tle

    dp时间空间都非常的庸俗（注释贴后面吧）

    dp来说有两种思路

    最简单的就是lr边界统计该范围内最小的和最大的，最后把这所有的最大最小枚举进去即可

    另一种就是利用双指针的移动来得到当前的一个范围内最大最小值，同时加和在答案上，显然空间上节约很多
    (i,i+1),(i,i+2),.......(i+1,i+2),(i+1,i+3)

    以第一个坐标轴的移动为外层循环，第二个坐标为内层循环

    记录一下单调栈的做法：

    🐎单调栈的作用是：
    递增递减取决于弹出栈后的顺序

    入栈的要求是要求元素大于或者小于栈顶元素

    tips:方便判断可以加入哨兵-1等用于优化可能取出栈中所有元素

    对于每一个nums[i]，他可能在所有区间内，分别担当了k1次的最大值，k2次的最小值。
    由于我们在前面两种做法的推导基础上，
    我们知道他对于最终答案的贡献是可以与num[i]本次所选择范围无关的，
    最终对ans的影响也一定是+num[i]*(k1-k2)

    k1，k2的值就需要我们利用单调栈的方法求得

    举例子，找区间最大值次数，就找i左右两边分别不满足小于等于的位置(p,q)，最终个数为k1=（i-p）(q-i)

    由于 nums[i]nums[i] 存在相同元素，
    因此上述两边均取等号的做法会导致某些区间被重复计算，
    因此我们可以令最近右端点的部分不取等号，
    确保区间统计不重不漏。(代码里面有体现)

    比如说在一个范围内，如果不这样处理，
    可能两个相同的2都会作为一次最小值出现，
    但是该范围（子数组）显然只使用了其中的一个2作为一个最小值来计算

    （谢谢评论区大佬）
    例子[1,2,2,1]，
    这里的两个2都会被算作在一个整个数组范围里面的最大值的一个次数显然是算多了，
    所以我们通过左开右闭来避免这种重复，并且保证重复的数字的区间范围只会被纳入一次

    截取评论里面说的很好的一句话：
**什么时候用单调栈**

    如果你作为一个队列中的人，你希望一眼看左（或者右）
    你最远能看到谁比你高（或者谁比你矮），那么就可以利用单调栈
    

### 521.最长特殊序列Ⅰ easy 3/5

    脑经急转弯，如果两个子符串不相同（不是长度），
    那么显然更长的字符串的本身一定不包含在更短字符串的子集里面，
    显然就是最长特殊，如果相同那么就不存在-1；
    

### 2100.适合打劫的日子 middle 3/6

    前缀和问题

    打劫的日子，简单的一个缩小范围，根据题意，时间肯定在[time,n-time]内，并且要求左非递增，右非递减

    首先维护一个数组[]g，g[i]记录s[i]与s[i-1]的关系，如果递增则为1，递减为-1，不变为0；

    随后分别用[]a,[]b记录时间i之前1和-1的数量

    那么对于时间i，如果a[i]-a[i-time]==0,b[i+time]-b[i]==0,则可以打劫

    注意这里时间和下标的问题，
    叶总的ab数组的下标从1到n，
    我这里就选择0到n-1和原始天数对应。



### 504.七进制数 easy 3/7

    简单模拟题

    有点需要注意的就是，构建转换的顺序问题，
    以及该题需要考虑一下负数的转换，记得判断一下


### 2055.蜡烛之间的盘子 middle 3/8


    对于每次查询，找出查询范围内
    必须在两根蜡烛之间的盘子的个数

    这显然对个数来说，减少时间复杂度的就利用前缀和。

    然后呢我们要找出哪两根蜡烛之间

    显然也是最靠近查询范围的蜡烛

    第一个首先最好想到查询蜡烛的方法是将蜡烛升序排列后，
    二分查找到离得最近的位置

    第二种方法是在构建前缀和的时候，就一并记录每一个位置左和右最近的蜡烛位置
    这里利用的是双指针的方法，分别从左和从右更新左最近和右最近蜡烛的位置（类似于更新哨兵方法）

**这里补充一下什么时候二分的mid使用r+l+1>>1还是r+l>>1**

    从例子中很好的得出mid的式子应该由后面mid的值跟着左边取等还是右边取等来决定
    （大于等于满足，小于不满足；或者是小于等于满足，大于不满足）
    
    核心是l与r要靠拢，那么就必须避免l或者r下一个变化仍然是原值（在lr靠近的时候发生）

    举个很简单的例子，如果此时l=r-1的时候
    如果有个条件l=mid
    那么如果mid=l+r>>1的话则可能出现死循环(l一开始就等于mid则一直不动)
    那么显然需要mid=l+r+1>>1
    同理对于r=mid,如果mid=l+r>>1的话也不会出现死循环

    也可以看出这里是由于整数的截断导致的一些小性质


### 798.得分最高的最小轮调 hard 3/9 🐎🐎 

    论调指的是把下标k及其以后的调到前面来
    k,k+1,....n-1,0,1,2....

    得分位值小于索引的+1分

    返回轮调位置

    上下界分析，差分应用

    好难艹
    差分数组f[i]=d[i]-d[i-1]
    (i>1)

    对于原先i位置，若k论调，
    则新位置在（n+k-i）mod n

    分析出原数组的每个nums[i]能够得分的k的取值范围，
    假定取值范围为[l,r]，我们可以对 [l, r]进行+1标记，

    本题目的范围显然不一定是[l,r]还有可能是[0,l] ∪ [r,n-1]
    
    暗示我们需要认真判断关系的交并关系

    代表范围为k能够得1分，

    当处理完所有的nums[i]后，

    找到标记次数最多的位置k即是答案。

    标记操作可使用「差分」实现

    差分和前缀和就是一个是微分一个是积分，有不同的使用范围

**差分数组对于求范围交集最多重合非常有用，这题也比较显著（找到被范围框住最多的k），入门模板1109. 航班预订统计**

    老实说我没怎么看懂叶总的判断，但是意思我倒是明白了
    写一点我自己的做法，和叶总最后结果是等价的

~~啊这跑完步发现自己明显分析错了，重来重来~~

    ①首先第一个限制就是k属于[0,n-1]
    
    ②我们直接令操作后的下标为i-k

    负数也没关系

    i-k >= nums[i]

    得出k第一个范围 k<=i-nums[i]

    然后这里如果要考虑i-k的正负关系，即映射到0,n-1上的话

    k<=i时 k<=i-nums[i]
    k>i时候 k<= n+i-nums[i]
    显然可以得出上面两个式子和下面式子等价（带上①的条件）
    可以得出k<=(i-nums[i]+n)%n

    ③ 最后我想了半天这个下界怎么想，我觉得这样思路更好，虽然你k由②得出了结论，但是我们也必须得思考一个问题，论调的时候，(i-nums[i]+n)%n在i得左右侧有不同的结果

    加入②<=i 当i>=nums[i]，那么不仅在[0,②]可以，在[i+1，n-1]也可以
    
    当 ②>i的时候 注意，我们这个时候要思考的就是，显然k选择[i+1，n-1]的时候是把i的改动后坐标i`放大，并且k越靠近i+1，就放的越大
    
**此时i<②<n-1，我们关注的点在于大于②的情况并不满足，证明什么，证明放大i坐标还需要放大足够多程度**

    那么显然如果k选择[0，i]是不可取的，所以我们还有一种范围是[i+1,②]


    最终可加分范围为[②,①] 或者[0,①],[②，n-1]

### 589.N叉树的前序遍历 easy 3/10

    分为递归做法和非递归做法

    主要这里是N叉树，栈的使用要操作一下

    再找题复习一下各种遍历的写法

    顺手还见识了Object类的一个骚操作

    不递归反而时间还变长了好多-- 尬